package books.java_main_service.model;import com.fasterxml.jackson.annotation.JsonManagedReference;import jakarta.persistence.*;import jakarta.validation.constraints.*;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import java.util.HashSet;import java.util.Set;@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Table(name = "books")public class Book {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @Column(nullable = false, length = 100)    @NotBlank(message = "Название не может быть пустым")    @Size(min = 1, max = 100, message = "Название должно содержать от 1 до 100 символов")    private String title;    @Column(nullable = false, length = 50)    @NotBlank(message = "Имя автора не может быть пустым")    @Size(min = 1, max = 50, message = "Имя автора должно содержать от 1 до 50 символов")    private String author;    @ManyToMany    @JoinTable(            name = "book_genres",            joinColumns = @JoinColumn(name = "book_id"),            inverseJoinColumns = @JoinColumn(name = "genre_id"))    @NotEmpty(message = "Книга должна иметь хотя бы один жанр")    private Set<Genre> genres = new HashSet<>();    @Column(name = "year_published", length = 4)    @Min(value = 1, message = "Год должен быть положительным числом")    @Max(value = 9999, message = "Год не может быть больше 9999")    private Integer year;    @Column(nullable = false, length = 2000)    @NotBlank(message = "Описание не может быть пустым")    @Size(min = 10, max = 2000, message = "Описание должно содержать от 10 до 2000 символов")    private String description;    @JsonManagedReference    @OneToMany(mappedBy = "book", cascade = CascadeType.ALL, orphanRemoval = true)    private Set<Review> reviews = new HashSet<>();    @Column(name = "avg_rating")    private Double averageRating;    @Column(name = "ratings_count")    @Min(0)    private Integer ratingsCount = 0;    @Column(name = "created_by")    private Long createdBy;    // Метод для расчета средней оценки    @Transient    public Double calculateAverageRating() {        if (reviews.isEmpty()) {            return 0.0;        }        return reviews.stream().mapToDouble(Review::getRating).average().orElse(0.0);    }    // Метод для обновления средней оценки    public void updateAverageRating() {        this.averageRating = calculateAverageRating();        this.ratingsCount = reviews.size();    }}