package books.java_main_service.service;import books.java_main_service.exception.HttpStatusException;import books.java_main_service.model.*;import books.java_main_service.repository.BookItemRepository;import books.java_main_service.repository.DealRepository;import books.java_main_service.repository.TotalDealsRepository;import jakarta.transaction.Transactional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Service;import java.time.LocalDateTime;import java.util.List;import static org.springframework.http.HttpStatus.BAD_REQUEST;@Servicepublic class DealService {    private final DealRepository dealRepository;    private final BookItemRepository bookItemRepository;    private final UserService userService;    private final TotalDealsRepository totalDealsRepository;    @Autowired    public DealService(            DealRepository dealRepository,            BookItemRepository bookItemRepository,            UserService userService,            TotalDealsRepository totalDealsRepository) {        this.dealRepository = dealRepository;        this.bookItemRepository = bookItemRepository;        this.userService = userService;        this.totalDealsRepository = totalDealsRepository;    }    // Метод для обновления статистики сделок юзера    private void updateTotalDeals(Long id, boolean incrementTotal, boolean incrementSuccessful) {        TotalDeals stats = totalDealsRepository.findById(id).orElse(new TotalDeals(id));        // Увеличиваем счетчик всех сделок        if (incrementTotal) {            stats.setTotalDeals(stats.getTotalDeals() + 1);        }        // Увеличиваем счетчик успешных сделок        if (incrementSuccessful) {            stats.setSuccessfulDeals(stats.getSuccessfulDeals() + 1);        }        // Сохраняем обновленную статистику        totalDealsRepository.save(stats);    }    // Метод для валидации предложения сделки    private void validateDealProposal(BookItem initiatorItem, BookItem receiverItem, Long userId) {        // Проверяем, что access_token инициатора совпадает с владельцем книги        if (!initiatorItem.getOwnerId().equals(userId)) {            throw new HttpStatusException(                    HttpStatus.FORBIDDEN, "Вы не являетесь владельцем этой книги");        }        // Проверяем, что книги доступны в целом        if (initiatorItem.getStatus() != BookItem.BookStatus.AVAILABLE                || receiverItem.getStatus() != BookItem.BookStatus.AVAILABLE) {            throw new HttpStatusException(BAD_REQUEST, "Обе книги должны быть доступны для обмена");        }        // Проверяем, что обе книги доступны для обмена,        // то есть пользователь ее перестал читать и готов обменять        if (!initiatorItem.getAvailableForDeal() || !receiverItem.getAvailableForDeal()) {            throw new HttpStatusException(BAD_REQUEST, "Обе книги должны быть доступны для обмена");        }        // Проверяем, что нет активных сделок с этими книгами        List<Deal.DealStatus> activeStatuses =                List.of(                        Deal.DealStatus.PROPOSED,                        Deal.DealStatus.ACCEPTED,                        Deal.DealStatus.COMPLETED);        if (dealRepository.existsActiveDeal(                initiatorItem.getId(), receiverItem.getId(), activeStatuses)) {            throw new HttpStatusException(                    HttpStatus.CONFLICT, "Одна из книг уже участвует в другой сделке");        }    }    // Метод для создания сделки    @Transactional    public Deal proposeDeal(Long initiatorItemId, Long receiverItemId, String accessToken) {        // Пррверка на валидность токена инциатора        String token = accessToken.startsWith("Bearer ") ? accessToken.substring(7) : accessToken;        UserMainData user = userService.getUserMainData(token);        // Получаем книгу инициатора        BookItem initiatorItem =                bookItemRepository                        .findById(initiatorItemId)                        .orElseThrow(                                () ->                                        new HttpStatusException(                                                HttpStatus.NOT_FOUND,                                                "Книга инициатора не найдена"));        // Получаем книгу получателя        BookItem receiverItem =                bookItemRepository                        .findById(receiverItemId)                        .orElseThrow(                                () ->                                        new HttpStatusException(                                                HttpStatus.NOT_FOUND,                                                "Книга получателя не найдена"));        // Проверяем, что книги инициатора и получателя принадлежат разным пользователям        // Проверяем, что они не участвуют в сделках        validateDealProposal(initiatorItem, receiverItem, user.getId());        // Создаем сделку        Deal deal = new Deal();        deal.setInitiatorItem(initiatorItem);        deal.setReceiverItem(receiverItem);        deal.setInitiatorId(user.getId());        deal.setReceiverId(receiverItem.getOwnerId());        deal.setStatus(Deal.DealStatus.PROPOSED);        // Резервируем книги        initiatorItem.setStatus(BookItem.BookStatus.RESERVED);        receiverItem.setStatus(BookItem.BookStatus.RESERVED);        bookItemRepository.save(initiatorItem);        bookItemRepository.save(receiverItem);        // Увеличиваем счетчик всех сделок        updateTotalDeals(user.getId(), true, false);        updateTotalDeals(receiverItem.getOwnerId(), true, false);        return dealRepository.save(deal);    }    // Метод для валидации принятия сделки    private Deal validateDealAction(            Long dealId,            String accessToken,            Deal.DealStatus requiredStatus,            String requiredUserRole) {        String token = accessToken.startsWith("Bearer ") ? accessToken.substring(7) : accessToken;        UserMainData user = userService.getUserMainData(token);        Deal deal =                dealRepository                        .findById(dealId)                        .orElseThrow(                                () ->                                        new HttpStatusException(                                                HttpStatus.NOT_FOUND, "Сделка не найдена"));        // Проверка, что пользователь участвует в сделке        if (!deal.getInitiatorId().equals(user.getId())                && !deal.getReceiverId().equals(user.getId())) {            throw new HttpStatusException(HttpStatus.FORBIDDEN, "У вас нет прав на эту сделку");        }        // Проверка роли пользователя в сделке        if ("INITIATOR".equals(requiredUserRole) && !deal.getInitiatorId().equals(user.getId())) {            throw new HttpStatusException(                    HttpStatus.FORBIDDEN, "Только инициатор может выполнить это действие");        } else if ("RECEIVER".equals(requiredUserRole)                && !deal.getReceiverId().equals(user.getId())) {            throw new HttpStatusException(                    HttpStatus.FORBIDDEN, "Только получатель может выполнить это действие");        }        // Проверка статуса        if (requiredStatus != null && deal.getStatus() != requiredStatus) {            throw new HttpStatusException(                    BAD_REQUEST, "Некорректный статус сделки. Ожидается: " + requiredStatus);        }        return deal;    }    // Метод для принятия сделки    @Transactional    public Deal acceptDeal(Long dealId, String accessToken) {        // Проверяем доступность сделки для принятия        Deal deal = validateDealAction(dealId, accessToken, Deal.DealStatus.PROPOSED, "RECEIVER");        // Обеовляем статус сделки на ACCEPTED        deal.setStatus(Deal.DealStatus.ACCEPTED);        // Сохраняем сделку        return dealRepository.save(deal);    }    // Метод для завершения сделки    @Transactional    public Deal completeDeal(Long dealId, String accessToken) {        // Проверяем доступность сделки для завершения        Deal deal = validateDealAction(dealId, accessToken, Deal.DealStatus.ACCEPTED, "INITIATOR");        // Получаем книги инициатора и получателя        BookItem initiatorItem = deal.getInitiatorItem();        BookItem receiverItem = deal.getReceiverItem();        // Меняем владельцев книг        Long tempOwnerId = initiatorItem.getOwnerId();        initiatorItem.setOwnerId(receiverItem.getOwnerId());        receiverItem.setOwnerId(tempOwnerId);        // Обновляем статус книг        initiatorItem.setStatus(BookItem.BookStatus.AVAILABLE);        receiverItem.setStatus(BookItem.BookStatus.AVAILABLE);        // Сохраняем обновленные книги        bookItemRepository.save(initiatorItem);        bookItemRepository.save(receiverItem);        // Обновляем статус сделки на COMPLETED        deal.setStatus(Deal.DealStatus.COMPLETED);        deal.setCompletedAt(LocalDateTime.now());        // Увеличиваем счетчик успешных сделок        updateTotalDeals(deal.getInitiatorId(), false, true);        updateTotalDeals(deal.getReceiverId(), false, true);        return dealRepository.save(deal);    }    // Метод для отмены сделки    @Transactional    public Deal cancelDeal(Long dealId, String accessToken) {        // Проверяем доступность сделки для отмены        Deal deal = validateDealAction(dealId, accessToken, null, "INITIATOR");        // Проверяем, что сделка не завершена или не отменена        if (deal.getStatus() == Deal.DealStatus.COMPLETED                || deal.getStatus() == Deal.DealStatus.CANCELLED) {            throw new HttpStatusException(BAD_REQUEST, "Эту сделку уже нельзя отменить");        }        // Получаем книги инициатора и получателя        BookItem initiatorItem = deal.getInitiatorItem();        BookItem receiverItem = deal.getReceiverItem();        // Возвращаем книги в статус AVAILABLE        initiatorItem.setStatus(BookItem.BookStatus.AVAILABLE);        receiverItem.setStatus(BookItem.BookStatus.AVAILABLE);        // Меняем статус сделки на CANCELLED        deal.setStatus(Deal.DealStatus.CANCELLED);        // Сохраняем обновленные книги        return dealRepository.save(deal);    }    // Метод для получения всех сделок пользователя    public List<Deal> getUserDeals(String accessToken) {        String token = accessToken.startsWith("Bearer ") ? accessToken.substring(7) : accessToken;        UserMainData user = userService.getUserMainData(token);        return dealRepository.findByInitiatorIdOrReceiverId(user.getId(), user.getId());    }    // Метод для получения статистики сделок, АДМИНИСТРАТОР    public List<TotalDeals> getAllTotalDeals(String accessToken) {        // Проверяем токен и получаем профиль пользователя        String token = accessToken.startsWith("Bearer ") ? accessToken.substring(7) : accessToken;        UserMainData user = userService.getUserMainData(token);        // Проверяем роль администратора        if (!"ADMIN".equals(user.getRole())) {            throw new HttpStatusException(                    HttpStatus.FORBIDDEN, "Доступ запрещен. Требуется роль администратора");        }        // Возвращаем все записи статистики        return totalDealsRepository.findAll();    }    // Метод для получения списка сделок какого-то пользователя, АДМИНИСТРАТОР    public List<Deal> getAllDeals(String accessToken, Long userId) {        // Проверяем токен и получаем профиль пользователя        String token = accessToken.startsWith("Bearer ") ? accessToken.substring(7) : accessToken;        UserMainData user = userService.getUserMainData(token);        // Проверяем роль администратора        if (!"ADMIN".equals(user.getRole())) {            throw new HttpStatusException(                    HttpStatus.FORBIDDEN, "Доступ запрещен. Требуется роль администратора");        }        // Возвращаем все записи статистик        return dealRepository.findByInitiatorIdOrReceiverId(userId, userId);    }}