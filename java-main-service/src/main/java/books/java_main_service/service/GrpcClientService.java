package books.java_main_service.service;import books.java_main_service.Auth;import books.java_main_service.AuthenticationGrpc;import books.java_main_service.exception.HttpStatusException;import books.java_main_service.model.UserProfileDTO;import books.java_main_service.model.UserUpdatePasswordDTO;import io.grpc.ManagedChannel;import io.grpc.ManagedChannelBuilder;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Service;@Servicepublic class GrpcClientService {    private final AuthenticationGrpc.AuthenticationBlockingStub blockingStub;    public GrpcClientService() {        // Читаем адрес gRPC сервера из переменной окружения        String authServerAddress = System.getenv("AUTH_SERVER_ADDRESS");        System.out.println("Auth server address: " + authServerAddress);        if (authServerAddress == null || authServerAddress.isEmpty()) {            throw new IllegalStateException("Переменная окружения AUTH_SERVER_ADDRESS не задана");        }        String[] parts = authServerAddress.split(":");        ManagedChannel channel =                ManagedChannelBuilder.forAddress(parts[0], Integer.parseInt(parts[1]))                        .usePlaintext()                        .build();        // Создаем блокирующий и асинхронный клиенты        this.blockingStub = AuthenticationGrpc.newBlockingStub(channel);    }    // Метод для создания пользователя    public Auth.UserProfileWithTokens addUser(String login, String password) {        Auth.UserRequest request =                Auth.UserRequest.newBuilder().setLogin(login).setPassword(password).build();        try {            return blockingStub.addUser(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.BAD_REQUEST, e.getMessage());        }    }    // Метод для авторизации    public Auth.UserProfileWithTokens authenticate(String login, String password) {        Auth.UserRequest request =                Auth.UserRequest.newBuilder().setLogin(login).setPassword(password).build();        try {            return blockingStub.auth(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.UNAUTHORIZED, e.getMessage());        }    }    // Метод для авторизации через токен    public Auth.UserProfile getUser(Long id) {        Auth.UserProfileRequest request = Auth.UserProfileRequest.newBuilder().setId(id).build();        try {            return blockingStub.getProfile(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.UNAUTHORIZED, e.getMessage());        }    }    // Метод для изменения данных через токен, кроме пароля    public Auth.UserProfileWithTokens updateUser(            UserProfileDTO user, Long id, String access_token) {        Auth.UserProfileWithTokens request =                Auth.UserProfileWithTokens.newBuilder()                        .setId(id)                        .setLogin(user.getLogin())                        .setMail(user.getMail())                        .setPhone(user.getPhone())                        .setAccessToken(access_token)                        .build();        try {            return blockingStub.changeProfile(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.UNAUTHORIZED, e.getMessage());        }    }    // Метод для обновления Access-токена    public Auth.AccessTokenResponse refreshToken(String refreshToken) {        Auth.RefreshTokenRequest request =                Auth.RefreshTokenRequest.newBuilder().setRefreshToken(refreshToken).build();        try {            return blockingStub.refreshAccessToken(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.UNAUTHORIZED, e.getMessage());        }    }    // Метод для получения айди и роли из токена    public Auth.UserMainDataResponse GetMainData(String accessToken) {        Auth.UserAccessRequest request =                Auth.UserAccessRequest.newBuilder().setAccessToken(accessToken).build();        try {            return blockingStub.getMainData(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.UNAUTHORIZED, e.getMessage());        }    }    // Метод для изменения пароля    public Auth.TokenResponse updatePassword(UserUpdatePasswordDTO user, Long id) {        Auth.PasswordChange request =                Auth.PasswordChange.newBuilder()                        .setOldPassword(user.getOldPassword())                        .setNewPassword(user.getNewPassword())                        .setId(id)                        .build();        try {            return blockingStub.changePassword(request);        } catch (Exception e) {            throw new HttpStatusException(HttpStatus.UNAUTHORIZED, e.getMessage());        }    }}