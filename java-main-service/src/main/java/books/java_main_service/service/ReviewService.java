package books.java_main_service.service;import books.java_main_service.exception.HttpStatusException;import books.java_main_service.model.Book;import books.java_main_service.model.Review;import books.java_main_service.model.UserMainData;import books.java_main_service.repository.BookRepository;import books.java_main_service.repository.ReviewRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Servicepublic class ReviewService {    private final ReviewRepository reviewRepository;    private final BookRepository bookRepository;    private final UserService userService;    @Autowired    public ReviewService(            ReviewRepository reviewRepository,            BookRepository bookRepository,            UserService userService) {        this.reviewRepository = reviewRepository;        this.bookRepository = bookRepository;        this.userService = userService;    }    public List<Review> getBookReviews(            Long bookId, Integer rating, String sortBy, String direction) {        // Cортировать по рейтингу (true) / по дате создания (false)        boolean byRating = sortBy != null && sortBy.equalsIgnoreCase("rating");        // По возрастанию (true) / по убыванию (false)        boolean ascending = direction != null && direction.equalsIgnoreCase("asc");        // Фильтрация по конкретному значению рейтинга        if (rating != null) {            if (byRating) {                // Сортировка по рейтингу + фильтр по конкретной оценке                return ascending                        ? reviewRepository.findByBookIdAndRatingOrderByRatingAsc(                                bookId, rating) // По возрастанию                        : reviewRepository.findByBookIdAndRatingOrderByRatingDesc(                                bookId, rating); // По убыванию            } else {                // Сортировка по дате + фильтр по конкретной оценке                return ascending                        ? reviewRepository.findByBookIdAndRatingOrderByCreatedAtAsc(                                bookId, rating) // От старых к новым                        : reviewRepository                                .findByBookIdAndRatingOrderByCreatedAtDesc( // От новых к старым                                        bookId, rating);            }        } else {            // Без фильтрация по конкретному значению рейтинга            if (byRating) {                // Только сортировка по рейтингу (все оценки)                return ascending                        ? reviewRepository.findByBookIdOrderByRatingAsc(                                bookId) // По возрастанию (от 1 к 5)                        : reviewRepository.findByBookIdOrderByRatingDesc(                                bookId); // По убыванию (от 5 к 1)            } else {                // Только сортировка по дате создания (все оценки)                return ascending                        ? reviewRepository.findByBookIdOrderByCreatedAtAsc(                                bookId) // От старых к новым                        : reviewRepository.findByBookIdOrderByCreatedAtDesc(                                bookId); // От новых к старым            }        }    }    public Review getReviewById(Long bookId, Long reviewId) {        return reviewRepository                .findByIdAndBookId(reviewId, bookId)                .orElseThrow(                        () ->                                new HttpStatusException(                                        HttpStatus.NOT_FOUND,                                        "Отзыв с ID "                                                + reviewId                                                + " для книги с ID "                                                + bookId                                                + " не найден"));    }    @Transactional    public Review addReview(Long bookId, Review review, String accessToken) {        // Получаем данные пользователя        String token = accessToken.startsWith("Bearer ") ? accessToken.substring(7) : accessToken;        UserMainData user = userService.getUserMainData(token);        // Находим книгу        Book book =                bookRepository                        .findById(bookId)                        .orElseThrow(                                () ->                                        new HttpStatusException(                                                HttpStatus.NOT_FOUND, "Книга не найдена"));        // Проверяем, не оставлял ли пользователь уже отзыв        boolean hasReview =                book.getReviews().stream().anyMatch(r -> r.getUserId().equals(user.getId()));        if (hasReview) {            throw new HttpStatusException(                    HttpStatus.CONFLICT, "Вы уже оставили отзыв на эту книгу");        }        // Заполняем данные отзыва        review.setUserId(user.getId());        review.setBook(book);        // Сохраняем отзыв        Review savedReview = reviewRepository.save(review);        // Обновляем рейтинг книги        book.getReviews().add(savedReview);        book.updateAverageRating();        bookRepository.save(book);        return savedReview;    }}