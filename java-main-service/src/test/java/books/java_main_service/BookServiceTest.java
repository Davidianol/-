package books.java_main_service;import books.java_main_service.exception.HttpStatusException;import books.java_main_service.model.Book;import books.java_main_service.model.BookItem;import books.java_main_service.model.UserMainData;import books.java_main_service.repository.BookItemRepository;import books.java_main_service.repository.BookRepository;import books.java_main_service.service.BookService;import books.java_main_service.service.UserService;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import org.springframework.http.HttpStatus;import java.util.Collections;import java.util.List;import java.util.Optional;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.ArgumentMatchers.*;import static org.mockito.Mockito.*;@ExtendWith(MockitoExtension.class)class BookServiceTest {    @Mock private BookRepository bookRepository;    @Mock private BookItemRepository bookItemRepository;    @Mock private UserService userService;    @InjectMocks private BookService bookService;    private Book testBook;    private BookItem testBookItem;    private UserMainData testUserMainData;    private final String testToken = "Bearer testToken";    private final String rawTestToken = "testToken";    @BeforeEach    void setUp() {        testUserMainData = new UserMainData(1L, "CLIENT");        testBook = new Book();        testBook.setId(1L);        testBook.setTitle("Тестовая книга");        testBook.setAuthor("Тестовый автор");        testBookItem = new BookItem();        testBookItem.setId(1L);        testBookItem.setBook(testBook);        testBookItem.setOwnerId(1L);        testBookItem.setStatus(BookItem.BookStatus.AVAILABLE);        testBookItem.setAvailableForDeal(true);    }    @Test    void findAllShouldReturnAllBooks() {        List<Book> expectedBooks = Collections.singletonList(testBook);        when(bookRepository.findAll()).thenReturn(expectedBooks);        List<Book> actualBooks = bookService.findAll();        assertEquals(expectedBooks, actualBooks);        verify(bookRepository).findAll();    }    @Test    void findByIdShouldReturnBookWhenExists() {        when(bookRepository.findById(1L)).thenReturn(Optional.of(testBook));        Optional<Book> result = bookService.findById(1L);        assertTrue(result.isPresent());        assertEquals(testBook, result.get());    }    @Test    void saveBookItemShouldThrowExceptionWhenBookNotFound() {        when(userService.getUserMainData(eq(rawTestToken))).thenReturn(testUserMainData);        when(bookRepository.findById(anyLong())).thenReturn(Optional.empty());        HttpStatusException exception =                assertThrows(                        HttpStatusException.class,                        () -> bookService.saveBookItem(testBookItem, 999L, testToken));        assertEquals(HttpStatus.BAD_REQUEST, exception.getHttpStatus());        assertTrue(exception.getMessage().contains("Книга с ID 999 не найдена"));    }    @Test    void saveBookItemShouldThrowExceptionWhenUserAlreadyHasItemForBook() {        when(userService.getUserMainData(eq(rawTestToken))).thenReturn(testUserMainData);        when(bookRepository.findById(1L)).thenReturn(Optional.of(testBook));        when(bookItemRepository.existsByBookIdAndOwnerId(1L, 1L)).thenReturn(true);        HttpStatusException exception =                assertThrows(                        HttpStatusException.class,                        () -> bookService.saveBookItem(testBookItem, 1L, testToken));        assertEquals(HttpStatus.CONFLICT, exception.getHttpStatus());        assertEquals("У вас уже есть экземпляр этой книги для обмена", exception.getMessage());    }    @Test    void saveBookItemShouldSaveItemSuccessfully() {        when(userService.getUserMainData(eq(rawTestToken))).thenReturn(testUserMainData);        when(bookRepository.findById(1L)).thenReturn(Optional.of(testBook));        when(bookItemRepository.existsByBookIdAndOwnerId(1L, 1L)).thenReturn(false);        when(bookItemRepository.save(any(BookItem.class))).thenReturn(testBookItem);        BookItem savedItem = bookService.saveBookItem(testBookItem, 1L, testToken);        assertEquals(testBook, savedItem.getBook());        assertEquals(testUserMainData.getId(), savedItem.getOwnerId());        verify(bookItemRepository).save(testBookItem);    }}