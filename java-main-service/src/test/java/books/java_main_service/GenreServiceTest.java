package books.java_main_service;import books.java_main_service.model.Genre;import books.java_main_service.repository.GenreRepository;import books.java_main_service.service.GenreService;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import java.util.Arrays;import java.util.Collections;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.ArgumentMatchers.anyList;import static org.mockito.Mockito.*;@ExtendWith(MockitoExtension.class)class GenreServiceTest {    @Mock private GenreRepository genreRepository;    @InjectMocks private GenreService genreService;    private Genre genre1;    private Genre genre2;    @BeforeEach    void setUp() {        genre1 = new Genre();        genre1.setId(1L);        genre1.setName("Фэнтези");        genre1.setMain(true);        genre2 = new Genre();        genre2.setId(2L);        genre2.setName("Детектив");        genre2.setMain(false);    }    @Test    void getAllGenresShouldReturnAllGenres() {        List<Genre> expectedGenres = Arrays.asList(genre1, genre2);        when(genreRepository.findAll()).thenReturn(expectedGenres);        List<Genre> actualGenres = genreService.getAllGenres();        assertEquals(expectedGenres, actualGenres);        verify(genreRepository).findAll();    }    @Test    void getMainGenresShouldReturnOnlyMainGenres() {        List<Genre> expectedGenres = Collections.singletonList(genre1);        when(genreRepository.findByIsMainTrue()).thenReturn(expectedGenres);        List<Genre> actualGenres = genreService.getMainGenres();        assertEquals(expectedGenres, actualGenres);        verify(genreRepository).findByIsMainTrue();    }    @Test    void findByNameContainingShouldReturnMatchingGenres() {        List<Genre> expectedGenres = Collections.singletonList(genre1);        when(genreRepository.findByNameContainingIgnoreCase("фэнт")).thenReturn(expectedGenres);        List<Genre> actualGenres = genreService.findByNameContaining("фэнт");        assertEquals(expectedGenres, actualGenres);        verify(genreRepository).findByNameContainingIgnoreCase("фэнт");    }    @Test    void initializeGenresShouldPopulateEmptyDatabase() {        when(genreRepository.count()).thenReturn(0L);        genreService.initializeGenres();        verify(genreRepository).saveAll(anyList());    }    @Test    void initializeGenresShouldNotModifyNonEmptyDatabase() {        when(genreRepository.count()).thenReturn(10L);        genreService.initializeGenres();        verify(genreRepository, never()).saveAll(anyList());    }}